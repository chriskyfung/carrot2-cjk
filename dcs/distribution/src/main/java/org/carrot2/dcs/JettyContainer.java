/*
 * Carrot2 project.
 *
 * Copyright (C) 2002-2025, Dawid Weiss, Stanisław Osiński.
 * All rights reserved.
 *
 * Refer to the full license file "carrot2.LICENSE"
 * in the root folder of the repository checkout or at:
 * https://www.carrot2.org/carrot2.LICENSE
 */
package org.carrot2.dcs;

import static com.carrotsearch.console.launcher.Loggers.CONSOLE;

import java.io.IOException;
import java.io.UncheckedIOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Locale;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import org.eclipse.jetty.compression.gzip.GzipCompression;
import org.eclipse.jetty.compression.server.CompressionConfig;
import org.eclipse.jetty.compression.server.CompressionHandler;
import org.eclipse.jetty.ee11.servlet.DefaultServlet;
import org.eclipse.jetty.ee11.webapp.WebAppContext;
import org.eclipse.jetty.server.Handler;
import org.eclipse.jetty.server.HttpConfiguration;
import org.eclipse.jetty.server.HttpConnectionFactory;
import org.eclipse.jetty.server.Server;
import org.eclipse.jetty.server.ServerConnector;
import org.eclipse.jetty.server.handler.ContextHandler;
import org.eclipse.jetty.server.handler.ContextHandlerCollection;
import org.eclipse.jetty.server.handler.ShutdownHandler;
import org.eclipse.jetty.util.component.AbstractLifeCycle;
import org.eclipse.jetty.util.component.LifeCycle;
import org.eclipse.jetty.util.thread.QueuedThreadPool;

public class JettyContainer {
  public static final String SERVICE_STARTED_ON = "Service started on port ";

  private final int port;
  private final String host;
  private final List<Path> webappContexts;
  private final String shutdownToken;
  private final boolean useGzip;

  private Server server;
  private ServerConnector connector;
  private Integer maxThreads;
  private Integer idleTime;

  public JettyContainer(
      int port,
      String host,
      List<Path> contexts,
      String shutdownToken,
      Integer maxThreads,
      boolean useGzip,
      Integer idleTime) {
    this.host = host;
    this.port = port;
    this.webappContexts = contexts;
    this.shutdownToken = shutdownToken;
    this.maxThreads = maxThreads;
    this.useGzip = useGzip;
    this.idleTime = idleTime;
  }

  public JettyContainer(
      int port,
      String host,
      Path contextRoot,
      String shutdownToken,
      Integer maxThreads,
      boolean useGzip,
      Integer idleTime) {
    this.host = host;
    this.port = port;
    this.webappContexts = listWebappContexts(contextRoot);
    this.shutdownToken = shutdownToken;
    this.maxThreads = maxThreads;
    this.useGzip = useGzip;
    this.idleTime = idleTime;
  }

  public static List<Path> listWebappContexts(Path webappRoot) {
    try (Stream<Path> list = Files.list(webappRoot)) {
      return list.filter(dir -> !Files.isDirectory(dir.resolve("WEB-INF").resolve("web.xml")))
          .toList();
    } catch (IOException e) {
      throw new UncheckedIOException(e);
    }
  }

  public void start() throws Exception {
    server = createServer();
    addContexts(server, connector, webappContexts);
    server.start();
  }

  public void join() throws InterruptedException {
    server.join();
  }

  public boolean isRunning() {
    return server.isRunning();
  }

  public void stop() throws Exception {
    server.stop();
  }

  public int getPort() {
    return connector.getLocalPort();
  }

  private void addContexts(Server server, ServerConnector connector, List<Path> webapps)
      throws IOException {
    ArrayList<WebAppContext> ctxHandlers = new ArrayList<>();
    for (Path context : webapps) {
      if (!Files.isRegularFile(context.resolve("WEB-INF").resolve("web.xml"))) {
        throw new RuntimeException(
            "Not a web application context folder?: " + context.toAbsolutePath());
      }

      String ctxName = context.getFileName().toString();
      String ctxPath = "root".equalsIgnoreCase(ctxName) ? "/" : "/" + ctxName;

      WebAppContext ctx = new WebAppContext();
      ctx.setContextPath(ctxPath);
      ctx.setThrowUnavailableOnStartupException(true);
      ctx.setWar(context.normalize().toAbsolutePath().toString());
      ctx.setParentLoaderPriority(true);

      // Don't allow directory listings and don't use mmap buffers for serving static content.
      ctx.setInitParameter(DefaultServlet.CONTEXT_INIT + "dirAllowed", "false");
      ctx.setInitParameter(DefaultServlet.CONTEXT_INIT + "minMappedFileSize", "0");

      CONSOLE.debug("Deploying context '{}' at: {}.", ctxName, ctxPath);
      ctxHandlers.add(ctx);
    }

    server.addEventListener(
        new LifeCycle.Listener() {
          @Override
          public void lifeCycleStarted(LifeCycle event) {
            CONSOLE.info(
                "The following contexts are available:\n"
                    + ctxHandlers.stream()
                        .filter(AbstractLifeCycle::isStarted)
                        .sorted(Comparator.comparing(ContextHandler::getContextPath))
                        .map(ctx -> formatContext(ctx, connector))
                        .collect(Collectors.joining("\n")));
          }

          private String formatContext(WebAppContext ctx, ServerConnector connector) {
            return String.format(
                Locale.ROOT,
                "  http://localhost:%s%-10s %s",
                connector.getLocalPort(),
                ctx.getContextPath(),
                ctx.getDisplayName());
          }
        });

    Handler contentHandler =
        new ContextHandlerCollection(ctxHandlers.toArray(new ContextHandler[0]));

    Handler topHandler;
    if (useGzip) {
      GzipCompression gzip = new GzipCompression();
      gzip.setMinCompressSize(1024);

      CompressionConfig config =
          CompressionConfig.builder()
              .compressIncludeMethod("GET")
              .compressIncludeMethod("POST")
              .compressIncludeMimeType("application/json")
              .compressIncludeMimeType("application/javascript")
              .compressIncludeMimeType("application/x-javascript")
              .compressIncludeMimeType("application/xml")
              .compressIncludeMimeType("font/woff2")
              .compressIncludeMimeType("text/css")
              .compressIncludeMimeType("text/jsx")
              .compressIncludeMimeType("text/html")
              .compressIncludeMimeType("image/svg+xml")
              .build();

      CompressionHandler compressionHandler = new CompressionHandler(contentHandler);
      compressionHandler.putCompression(gzip);
      compressionHandler.putConfiguration("/*", config);
      topHandler = compressionHandler;
    } else {
      topHandler = contentHandler;
    }

    if (shutdownToken != null && !shutdownToken.trim().isEmpty()) {
      topHandler = new ShutdownHandler(topHandler, null, shutdownToken, false);
    }

    server.setHandler(topHandler);
  }

  private LifeCycle.Listener createLifecycleLogger(ServerConnector connector) {
    return new LifeCycle.Listener() {
      @Override
      public void lifeCycleStarted(LifeCycle event) {
        CONSOLE.info(
            "{}{}{}.",
            SERVICE_STARTED_ON,
            connector.getLocalPort(),
            connector.getHost() == null ? "" : " of interface " + connector.getHost());
      }

      @Override
      public void lifeCycleStopping(LifeCycle event) {
        CONSOLE.info("Service stopping...");
      }

      @Override
      public void lifeCycleStopped(LifeCycle event) {
        CONSOLE.info("Service stopped.");
      }

      @Override
      public void lifeCycleFailure(LifeCycle event, Throwable ex) {
        CONSOLE.trace("Server failed to start.", ex);

        try {
          JettyContainer.this.stop();
        } catch (Exception e) {
          CONSOLE.error("Could not stop the server.", e);
        }
      }
    };
  }

  private Server createServer() {
    QueuedThreadPool threadPool =
        new QueuedThreadPool() {
          private AtomicInteger tid = new AtomicInteger();

          @Override
          public Thread newThread(Runnable runnable) {
            return new Thread(
                () -> {
                  Thread.currentThread().setName("T" + tid.incrementAndGet());
                  runnable.run();
                });
          }
        };

    if (maxThreads != null) {
      threadPool.setMaxThreads(maxThreads);
    }

    // Turn off returning HTTP server version string.
    HttpConfiguration httpConfig = new HttpConfiguration();
    httpConfig.setSendXPoweredBy(false);
    httpConfig.setSendServerVersion(false);

    Server server = new Server(threadPool);
    connector = new ServerConnector(server, new HttpConnectionFactory(httpConfig));
    connector.setPort(port);
    connector.setHost(host);
    if (idleTime != null) {
      connector.setIdleTimeout(idleTime);
    }
    server.addConnector(connector);
    server.addEventListener(createLifecycleLogger(connector));
    return server;
  }
}
